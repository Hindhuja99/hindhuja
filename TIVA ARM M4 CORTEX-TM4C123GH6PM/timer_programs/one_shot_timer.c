// ONE SHOT TIMER WITH SWITCH    	
#include <stdint.h>
#include "tm4c123gh6pm.h"
int a, b, c;
int main(void)
{
	SYSCTL_RCC_R |= SYSCTL_RCC_USESYSDIV | SYSCTL_RCC_XTAL_16MHZ | SYSCTL_DC1_MINSYSDIV_25;//0x02400540;// setting up system clock //USESYSDIV=1,XTAL=0X15(10:6)16Mhz,OSCSRC=0X0,SYSDIV=0X4(1/5),
	SYSCTL_RCGCGPIO_R = SYSCTL_RCGCGPIO_R5;//SYSTEM PHERIPHERAL clock ENABLE
	GPIO_PORTF_DEN_R |= 0x0000001F;
	GPIO_PORTF_DIR_R |= 0x0000000F;
	GPIO_PORTF_PUR_R |= 0x10;
	SYSCTL_RCGCTIMER_R |= SYSCTL_RCGCTIMER_R0;

	while (1)
	{
		a = GPIO_PORTF_DATA_R & 0X10;
		c = 0;

		if (a == 0X00000000)
		{
			TIMER0_CTL_R &= ~TIMER_CTL_TAEN;// TIMER0 DISABLED
			TIMER0_CFG_R |= TIMER_CFG_32_BIT_TIMER;//For a 16/32-bit timer, this value selects the 16-bit timer configuration.
			TIMER0_TAMR_R |= TIMER_TAMR_TAMR_1_SHOT;//PERIOD-Periodic Timer mode
			TIMER0_TAILR_R = 1600000;//HARDWARE REGISTER WRITE VALUE 60000 TO LOCATION CORRESPONDS TO TIMER LOAD(CAPTURE)(TIMER0_TAILR_R -REGISTER)(GPTMTAILR)
			NVIC_EN0_R |= 0X00080000;// SET INTERRUPT(ENABLE)
			TIMER0_IMR_R |= TIMER_IMR_TATOIM;//GPTM Timer A Time-Out Interrupt MASK
			TIMER0_CTL_R |= TIMER_CTL_TAEN;//TIMER0 ENABLED
			GPIO_PORTF_DATA_R = 0X08;
		}
	}
}
void Timer0IntHandler(void)
{
	TIMER0_ICR_R = 0X00000001;
	GPIO_PORTF_DATA_R ^= 0x08;// write back the opposite state
}
